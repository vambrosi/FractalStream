configuration:
  title: Configuration
  size: 400x200
  vertical-contents:
    - text-entry:
        label: "f(z) = z¬≤ +"
        value: "-0.11 + 0.78i"
        type: ‚ÑÇ
        variable: C
    - text-entry:
        label: "Max. iterations:"
        value: "100"
        type: ‚Ñ§
        variable: max_iters
    - text-entry:
        label: "Escape radius:"
        value: 10
        type: ‚Ñù
        variable: escape_radius

viewers:
  - title: Parameter plane
    style: complex-plane
    size: 512x512
    resizable: true
    z-coord: C
    initial-center: 0
    initial-pixel-size: 1/128
    code: |
      z : ‚ÑÇ ‚≠† 0
      k : ‚Ñ§ ‚≠† 0
      while k < max_iters and |z| < escape_radius
        z ‚≠† z¬≤ + C
        k ‚≠† k + 1
      if |z| < escape_radius then
        color ‚≠† black
      else
        # see https://linas.org/art-gallery/escape/ray.html
        m : ‚Ñù ‚≠† k + 1 - log (log (|z|¬≤) / (2 log escape_radius)) / log 2
        base_color : Color ‚≠† if im z > 0 then dark purple else dark green
        color ‚≠† blend (cos (œÄ m / 20)¬≤, base_color, light base_color)

    tools:
      - name: Parameter plane external rays
        shortcut: r
        configuration:
          title: Parameter ray
          size: 400x200
          vertical-contents:
            - panel:
                title: p/q
                horizontal-contents:
                  - text-entry:
                      label: "Numerators: "
                      value: "0, 1, 2"
                      type: List of ‚Ñ§
                      variable: ps
                  - text-entry:
                      label: "Denominator: "
                      value: "3"
                      type: ‚Ñ§
                      variable: q
            - panel:
                title: Approximation settings
                vertical-contents:
                  - text-entry:
                      label: "Subdivisions per level set: "
                      value: "10"
                      type: ‚Ñ§
                      variable: S
                  - text-entry:
                      label: "Step size"
                      value: "0.0001"
                      type: ‚Ñù
                      variable: error
                  - text-entry:
                      label: "Newton iteration limit"
                      value: "100"
                      type: ‚Ñ§
                      variable: iter_limit
        actions:
            - event: refresh
              code: |
                erase

                # This is nearly a literal copy of
                # https://github.com/sagemath/sage/blob/develop/src/sage/dynamics/complex_dynamics/mandel_julia_helper.pyx#L179-L287

                for each p in ps do
                  D : ‚Ñ§ ‚≠† max_iters
                  R : ‚Ñù ‚≠† escape_radius

                  theta : ‚Ñù ‚≠† p / q
                  z : ‚ÑÇ ‚≠† R e^{2 œÄ ùëñ theta}

                  dist : ‚Ñù ‚≠† error

                  k : ‚Ñ§ ‚≠† 0
                  while k < D and dist >= error
                    k ‚≠† k + 1
                    j : ‚Ñ§ ‚≠† 0
                    while j < S and dist >= error
                      j ‚≠† j + 1
                      m : ‚Ñù ‚≠† (k - 1) S + j
                      r_m : ‚Ñù ‚≠† R^(2^(-m / S))
                      t_m : ‚ÑÇ ‚≠† r_m^(2^k) e^{2^{k+1} œÄ ùëñ theta}
                      temp_c : ‚ÑÇ ‚≠† z
                      difference : ‚Ñù ‚≠† error

                      C_k : ‚ÑÇ ‚≠† temp_c
                      D_k : ‚ÑÇ ‚≠† 1

                      n : ‚Ñ§ ‚≠† 0
                      while difference >= error and n < iter_limit
                        n ‚≠† n + 1
                        old_c : ‚ÑÇ ‚≠† temp_c
                        C_k ‚≠† old_c
                        D_k ‚≠† 1

                      # Work out C_k = f^{\circ k}(z) and D_k = d/dz (f^{\circ k}(z))
                        t : ‚Ñ§ ‚≠† 0
                        while t < k
                          t ‚≠† t + 1
                          D_k ‚≠† 2 D_k C_k + 1
                          C_k ‚≠† C_k¬≤ + old_c

                      # Use C_k and D_k to take one step of Newton's method for
                      # f^{\circ(k)}(z) - t_m
                        temp_c ‚≠† old_c - (C_k - t_m) / D_k
                        difference ‚≠† |old_c - temp_c|

                      if n = iter_limit then
                        dist ‚≠† 0 # failed to converge, break out of the loops
                        draw filled circle at z with radius error
                      else
                        dist ‚≠† 2 |C_k| log |C_k| / |D_k|
                        draw line from z to temp_c
                        z ‚≠† temp_c

            - event: deactivated
              code: erase

  - title: Dynamical plane
    style: complex-plane
    size: 512x512
    resizable: true
    z-coord: z
    pixel-size: px
    initial-center: 0
    initial-pixel-size: 1/128
    code: |
      k : ‚Ñ§ ‚≠† 0
      while k < max_iters and |z| < escape_radius
        z ‚≠† z¬≤ + C
        k ‚≠† k + 1
      if |z| < escape_radius then
        color ‚≠† black
      else
        # see https://linas.org/art-gallery/escape/ray.html
        m : ‚Ñù ‚≠† k + 1 - log (log (|z|¬≤) / (2 log escape_radius)) / log 2
        base_color : Color ‚≠† if im z > 0 then dark purple else dark green
        color ‚≠† blend (cos (œÄ m / 20)¬≤, base_color, light base_color)

    tools:

      - name: Dynamical plane external rays
        shortcut: r
        configuration:
          title: Parameter ray
          size: 400x200
          vertical-contents:
            - panel:
                title: p/q
                horizontal-contents:
                  - text-entry:
                      label: "Numerators:"
                      value: "1, 2, 4"
                      type: List of ‚Ñ§
                      variable: ps
                  - text-entry:
                      label: "Denominator:"
                      value: "7"
                      type: ‚Ñ§
                      variable: q
            - panel:
                title: Approximation settings
                vertical-contents:
                  - text-entry:
                      label: "Subdivisions per level set: "
                      value: "10"
                      type: ‚Ñ§
                      variable: S
                  - text-entry:
                      label: "Step size"
                      value: "0.0001"
                      type: ‚Ñù
                      variable: error
                  - text-entry:
                      label: "Newton iteration limit"
                      value: "100"
                      type: ‚Ñ§
                      variable: iter_limit

        actions:
            - event: refresh
              code: |
                erase

                for each p in ps do

                  D : ‚Ñ§ ‚≠† max_iters
                  R : ‚Ñù ‚≠† escape_radius

                  theta : ‚Ñù ‚≠† p / q
                  z : ‚ÑÇ ‚≠† R e^{2 œÄ ùëñ theta}

                  dist : ‚Ñù ‚≠† error

                  k : ‚Ñ§ ‚≠† 0
                  while k < D and dist >= error
                    k ‚≠† k + 1
                    j : ‚Ñ§ ‚≠† 0
                    while j < S and dist >= error
                      j ‚≠† j + 1
                      m : ‚Ñù ‚≠† (k - 1) S + j
                      r_m : ‚Ñù ‚≠† R^(2^(-m / S))
                      t_m : ‚ÑÇ ‚≠† r_m^(2^k) e^{2^{k+1} œÄ ùëñ theta}

                      difference : ‚Ñù ‚≠† error

                      temp_z : ‚ÑÇ ‚≠† z

                      # these get initialized for real below, in the loop
                      z_k : ‚ÑÇ ‚≠† 0
                      dz_k : ‚ÑÇ ‚≠† 0

                      n : ‚Ñ§ ‚≠† 0
                      while difference >= error and n < iter_limit
                        n ‚≠† n + 1

                        old_z : ‚ÑÇ ‚≠† temp_z
                        z_k ‚≠† temp_z
                        dz_k ‚≠† 1

                        # Work out z_k = f^{\circ k}(z) and dz_k = d/dz (f^{\circ k}(z))
                        t : ‚Ñ§ ‚≠† 0
                        while t < k
                          t ‚≠† t + 1
                          dz_k ‚≠† 2 dz_k z_k
                          z_k ‚≠† z_k¬≤ + C

                        # Use z_k and dz_k to take one step of Newton's method for
                        # f^{\circ(k)}(z) - t_m
                        temp_z ‚≠† old_z - (z_k - t_m) / dz_k
                        difference ‚≠† |old_z - temp_z|

                      if n = iter_limit then
                        dist ‚≠† 0 # failed to converge, break out of the loops
                        draw filled circle at z with radius error
                      else
                        dist ‚≠† |z - temp_z|
                        draw line from z to temp_z
                        z ‚≠† temp_z

            - event: deactivated
              code: erase
