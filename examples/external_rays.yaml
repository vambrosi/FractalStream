configuration:
  title: Configuration
  size: 400x200
  vertical-contents:
    - text-entry:
        label: "f(z) = zÂ² +"
        value: "-0.11 + 0.78i"
        type: â„‚
        variable: C
    - text-entry:
        label: "Max. iterations:"
        value: "100"
        type: â„¤
        variable: max_iters
    - text-entry:
        label: "Escape radius:"
        value: 10
        type: â„
        variable: escape_radius

viewers:
  - title: Parameter plane
    style: complex-plane
    size: 512x512
    resizable: true
    z-coord: C
    escape-radius: escape_radius
    iteration-limit: max_iters
    initial-center: 0
    initial-pixel-size: 1/128
    code: |
      z : â„‚ â­  0
      iterate z âŸ¼ zÂ² + C until z escapes

      color â­  black
      if z escapes:
        # see https://linas.org/art-gallery/escape/ray.html
        m : â„ â­  iterations + 1 ...
                 - log (log (|z|Â²) / (2 log escape_radius)) / log 2
        base_color : Color â­  if im z > 0 then dark purple else dark green
        color â­  blend (cos (Ï€ m / 20)Â², base_color, light base_color)

    tools:
      - name: Parameter plane external rays
        shortcut: r
        configuration:
          title: Parameter ray
          size: 400x200
          vertical-contents:
            - panel:
                title: p/q
                horizontal-contents:
                  - text-entry:
                      label: "Numerators: "
                      value: "0, 1, 2"
                      type: List of â„¤
                      variable: ps
                  - text-entry:
                      label: "Denominator: "
                      value: "3"
                      type: â„¤
                      variable: q
            - panel:
                title: Approximation settings
                vertical-contents:
                  - text-entry:
                      label: "Subdivisions per level set: "
                      value: "10"
                      type: â„¤
                      variable: S
                  - text-entry:
                      label: "Step size"
                      value: "0.0001"
                      type: â„
                      variable: error
                  - text-entry:
                      label: "Newton iteration limit"
                      value: "100"
                      type: â„¤
                      variable: iter_limit
        actions:
            - event: refresh
              code: |
                erase

                # This is nearly a literal copy of
                # https://github.com/sagemath/sage/blob/develop/src/sage/dynamics/complex_dynamics/mandel_julia_helper.pyx#L179-L287

                for each p in ps:

                  R : â„ â­  escape_radius

                  theta : â„ â­  p / q
                  z : â„‚ â­  R e^{2 Ï€ ð‘– theta}

                  dist : â„ â­  error

                  k : â„¤ â­  0
                  while dist >= error:
                    k â­  k + 1
                    j : â„¤ â­  0
                    while j < S and dist >= error:
                      j â­  j + 1
                      m : â„ â­  (k - 1) S + j
                      r_m : â„ â­  R^(2^(-m / S))
                      t_m : â„‚ â­  r_m^(2^k) e^{2^{k+1} Ï€ ð‘– theta}
                      temp_c : â„‚ â­  z
                      difference : â„ â­  error

                      C_k : â„‚ â­  temp_c
                      D_k : â„‚ â­  1

                      n : â„¤ â­  0
                      while difference >= error up to iter_limit times:
                        n â­  n + 1
                        old_c : â„‚ â­  temp_c
                        C_k â­  old_c
                        D_k â­  1

                        # Work out C_k = f^{\circ k}(z) and
                        # D_k = d/dz (f^{\circ k}(z))
                        while true up to k times:
                          D_k â­  2 D_k C_k + 1
                          C_k â­  C_kÂ² + old_c

                        # Use C_k and D_k to take one step of
                        # Newton's method for f^{\circ(k)}(z) - t_m
                        temp_c â­  old_c - (C_k - t_m) / D_k
                        difference â­  |old_c - temp_c|

                      if difference < error:
                        dist â­  2 |C_k| log |C_k| / |D_k|
                        draw line from z to temp_c
                        z â­  temp_c
                      else:
                        dist â­  0 # failed to converge, break out of the loops
                        draw filled circle at z with radius error

            - event: deactivated
              code: erase

  - title: Dynamical plane
    style: complex-plane
    size: 512x512
    resizable: true
    z-coord: z
    escape-radius: escape_radius
    iteration-limit: max_iters
    pixel-size: px
    initial-center: 0
    initial-pixel-size: 1/128
    code: |
      iterate z âŸ¼ zÂ² + C until z escapes

      color â­  black
      if z escaped:
        # see https://linas.org/art-gallery/escape/ray.html
        m : â„ â­  iterations + 1 ...
                 - log (log (|z|Â²) / (2 log escape_radius)) / log 2
        base_color : Color â­  if im z > 0 then dark purple else dark green
        color â­  blend (cos (Ï€ m / 20)Â², base_color, light base_color)

    tools:

      - name: Dynamical plane external rays
        shortcut: r
        configuration:
          title: Parameter ray
          size: 400x200
          vertical-contents:
            - panel:
                title: p/q
                horizontal-contents:
                  - text-entry:
                      label: "Numerators:"
                      value: "1, 2, 4"
                      type: List of â„¤
                      variable: ps
                  - text-entry:
                      label: "Denominator:"
                      value: "7"
                      type: â„¤
                      variable: q
            - panel:
                title: Approximation settings
                vertical-contents:
                  - text-entry:
                      label: "Subdivisions per level set: "
                      value: "10"
                      type: â„¤
                      variable: S
                  - text-entry:
                      label: "Step size"
                      value: "0.0001"
                      type: â„
                      variable: error
                  - text-entry:
                      label: "Newton iteration limit"
                      value: "100"
                      type: â„¤
                      variable: iter_limit

        actions:
            - event: refresh
              code: |
                erase

                for each p in ps:

                  R : â„ â­  escape_radius

                  theta : â„ â­  p / q
                  z â­  R e^{2 Ï€ ð‘– theta}

                  dist : â„ â­  error

                  k : â„¤ â­  0
                  while dist >= error:
                    k â­  k + 1
                    j : â„¤ â­  0
                    while dist >= error up to S times:
                      j â­  j + 1
                      m : â„ â­  (k - 1) S + j
                      r_m : â„ â­  R^(2^(-m / S))
                      t_m : â„‚ â­  r_m^(2^k) e^{2^{k+1} Ï€ ð‘– theta}

                      difference : â„ â­  error

                      temp_z : â„‚ â­  z

                      # these get initialized for real below, in the loop
                      z_k : â„‚ â­  0
                      dz_k : â„‚ â­  0

                      while difference >= error up to iter_limit times:

                        old_z : â„‚ â­  temp_z
                        z_k â­  temp_z
                        dz_k â­  1

                        # Work out z_k = f^{\circ k}(z) and
                        # dz_k = d/dz (f^{\circ k}(z))
                        t : â„¤ â­  0
                        while t < k:
                          t â­  t + 1
                          dz_k â­  2 dz_k z_k
                          z_k â­  z_kÂ² + C

                        # Use z_k and dz_k to take one step of
                        # Newton's method for f^{\circ(k)}(z) - t_m
                        temp_z â­  old_z - (z_k - t_m) / dz_k
                        difference â­  |old_z - temp_z|

                      if difference < error:
                        dist â­  |z - temp_z|
                        draw line from z to temp_z
                        z â­  temp_z
                      else:
                        dist â­  0 # failed to converge, break out of the loops
                        draw filled circle at z with radius error

            - event: deactivated
              code: erase
